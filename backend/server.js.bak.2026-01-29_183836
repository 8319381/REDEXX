require('dotenv').config();

const express = require('express');
const cors = require('cors');
const db = require("./db");
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 3001;

if (!process.env.JWT_SECRET) {
  console.error("FATAL: JWT_SECRET is not set in .env");
  process.exit(1);
}

app.use(cors());
app.use(express.json());

// Static lists (ok to keep in code)
const routes = [
  { from: 'Москва', to: 'Шанхай' },
  { from: 'Москва', to: 'Пекин' },
  { from: 'Москва', to: 'Нингбо' },
  { from: 'Москва', to: 'Циндао' },
  { from: 'Москва', to: 'Яньтянь' },
  { from: 'Санкт-Петербург', to: 'Шанхай' },
  { from: 'Санкт-Петербург', to: 'Пекин' },
  { from: 'Санкт-Петербург', to: 'Нингбо' },
  { from: 'Екатеринбург', to: 'Шанхай' },
  { from: 'Екатеринбург', to: 'Гуанчжоу' }
];
const containerTypes = ["20'", "20' Heavy", "40'", "40' HC"];

// Auth middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.sendStatus(401);

  jwt.verify(token, process.env.JWT_SECRET, (err, payload) => {
    if (err) return res.sendStatus(403);
    req.user = payload; // {id,email,role}
    next();
  });
};

const normalizeEmail = (email) => String(email || "").trim().toLowerCase();

const signToken = (user) => jwt.sign(
  { id: user.id, email: user.email, role: user.role },
  process.env.JWT_SECRET,
  { expiresIn: "7d" }
);

// Health check to DB (startup)
db.query("select 1")
  .then(() => console.log("DB: OK"))
  .catch((e) => console.error("DB: FAIL", e.message));

// --- AUTH ---
// POST /api/register {email,password,role}
app.post('/api/register', async (req, res) => {
  try {
    const email = normalizeEmail(req.body.email);
    const password = String(req.body.password || "");
    const role = String(req.body.role || "").trim();

    if (!email || !password || !role) {
      return res.status(400).json({ message: "email/password/role required" });
    }
    if (!["buyer", "logistician"].includes(role)) {
      return res.status(400).json({ message: "role must be buyer or logistician" });
    }
    if (password.length < 3) {
      return res.status(400).json({ message: "password too short" });
    }

    const exists = await db.query("select id from users where email=$1", [email]);
    if (exists.rows.length) {
      return res.status(400).json({ message: "User already exists" });
    }

    const passwordHash = await bcrypt.hash(password, 10);

    const ins = await db.query(
      "insert into users(email, password_hash, role) values ($1,$2,$3) returning id,email,role,created_at",
      [email, passwordHash, role]
    );

    const user = ins.rows[0];
    const token = signToken(user);

    res.json({
      token,
      user: { id: user.id, email: user.email, role: user.role, createdAt: user.created_at }
    });
  } catch (e) {
    console.error("REGISTER ERROR:", e);
    res.status(500).json({ message: "Error creating user" });
  }
});

// POST /api/login {email,password}
app.post('/api/login', async (req, res) => {
  try {
    const email = normalizeEmail(req.body.email);
    const password = String(req.body.password || "");

    if (!email || !password) {
      return res.status(400).json({ message: "email/password required" });
    }

    const q = await db.query(
      "select id,email,password_hash,role,created_at from users where email=$1",
      [email]
    );
    if (!q.rows.length) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    const user = q.rows[0];
    const ok = await bcrypt.compare(password, user.password_hash);
    if (!ok) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    const token = signToken(user);

    res.json({
      token,
      user: { id: user.id, email: user.email, role: user.role, createdAt: user.created_at }
    });
  } catch (e) {
    console.error("LOGIN ERROR:", e);
    res.status(500).json({ message: "Error logging in" });
  }
});

// --- BETS ---
// POST /api/bets
app.post('/api/bets', authenticateToken, async (req, res) => {
  try {
    const {
      route,
      transportType,
      cost,
      deliveryDays,
      isCounterBid,
      originalBetId
    } = req.body || {};

    const betId = crypto.randomUUID();

    const data = {
      id: betId,
      userId: req.user.id,
      userEmail: req.user.email,
      userRole: req.user.role,
      route: route || null,
      transportType: transportType || null,
      cost: cost === undefined ? null : Number(cost),
      deliveryDays: deliveryDays === undefined ? null : Number(deliveryDays),
      isCounterBid: !!isCounterBid,
      originalBetId: originalBetId || null
    };

    const ins = await db.query(
      "insert into bets(bet_id, data) values ($1, $2::jsonb) returning created_at",
      [betId, JSON.stringify(data)]
    );

    res.json({ ...data, createdAt: ins.rows[0].created_at });
  } catch (e) {
    console.error("POST /api/bets ERROR:", e);
    res.status(500).json({ message: "Error creating bet" });
  }
});

// GET /api/bets
app.get('/api/bets', authenticateToken, async (req, res) => {
  try {
    const q = await db.query(
      "select bet_id, data, created_at from bets order by created_at asc limit 1000"
    );

    const all = q.rows.map(r => ({
      id: r.bet_id,
      ...(r.data || {}),
      createdAt: r.created_at
    }));

    // for looking up originals
    const byId = new Map(all.map(b => [b.id, b]));

    let userBets;
    if (req.user.role === 'logistician') {
      userBets = all.filter(b =>
        b.userId === req.user.id ||
        (b.isCounterBid && b.originalBetId && byId.get(b.originalBetId)?.userId === req.user.id)
      );
    } else {
      userBets = all.filter(b =>
        b.userRole === 'logistician' ||
        (b.isCounterBid && b.userId === req.user.id)
      );
    }

    res.json(userBets);
  } catch (e) {
    console.error("GET /api/bets ERROR:", e);
    res.status(500).json({ message: "Error fetching bets" });
  }
});

// --- PUBLIC LISTS ---
app.get('/api/routes', (req, res) => res.json(routes));
app.get('/api/container-types', (req, res) => res.json(containerTypes));

app.get('/api/best-offers', (req, res) => {
  res.json([
    { id: 1, from: 'Москва', to: 'Шанхай', price: 270000, days: 35, containerType: "20' Heavy" },
    { id: 2, from: 'Москва', to: 'Нингбо', price: 274000, days: 32, containerType: "20' Heavy" },
    { id: 3, from: 'Москва', to: 'Циндао', price: 279000, days: 34, containerType: "20' Heavy" },
    { id: 4, from: 'Москва', to: 'Яньтянь', price: 288000, days: 36, containerType: "20' Heavy" }
  ]);
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
