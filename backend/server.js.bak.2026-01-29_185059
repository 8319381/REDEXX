require('dotenv').config();

const express = require('express');
const cors = require('cors');
const db = require('./db');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 3001;

if (!process.env.JWT_SECRET) {
  console.error("FATAL: JWT_SECRET is not set in .env");
  process.exit(1);
}

app.use(cors());
app.use(express.json());

// Static lists (ok to keep in code)
const routes = [
  { from: 'Москва', to: 'Шанхай' },
  { from: 'Москва', to: 'Пекин' },
  { from: 'Москва', to: 'Нингбо' },
  { from: 'Москва', to: 'Циндао' },
  { from: 'Москва', to: 'Яньтянь' },
  { from: 'Санкт-Петербург', to: 'Шанхай' },
  { from: 'Санкт-Петербург', to: 'Пекин' },
  { from: 'Санкт-Петербург', to: 'Нингбо' },
  { from: 'Екатеринбург', to: 'Шанхай' },
  { from: 'Екатеринбург', to: 'Гуанчжоу' }
];
const containerTypes = ["20'", "20' Heavy", "40'", "40' HC"];

// Helpers
function signToken(user) {
  return jwt.sign(
    { id: user.id, email: user.email, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );
}

// Auth middleware
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.sendStatus(401);

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
}

// Health (DB check)
app.get('/api/health', async (req, res) => {
  try {
    const r = await db.query('select now()');
    res.json({ ok: true, now: r.rows[0].now });
  } catch (e) {
    res.status(500).json({ ok: false, error: 'DB error' });
  }
});

// Register
app.post('/api/register', async (req, res) => {
  try {
    const { email, password, role } = req.body;
    if (!email || !password) return res.status(400).json({ message: 'email and password required' });

    const normalizedRole = (role === 'logistician' || role === 'buyer') ? role : 'buyer';

    const exists = await db.query('select id from users where email=$1', [email]);
    if (exists.rows.length) return res.status(400).json({ message: 'User already exists' });

    const passwordHash = await bcrypt.hash(password, 10);

    const ins = await db.query(
      'insert into users(email, password_hash, role) values ($1,$2,$3) returning id,email,role,created_at',
      [email, passwordHash, normalizedRole]
    );

    const user = ins.rows[0];
    const token = signToken(user);

    res.json({ token, user: { id: user.id, email: user.email, role: user.role, created_at: user.created_at } });
  } catch (e) {
    console.error(e);
    res.status(500).json({ message: 'Error creating user' });
  }
});

// Login
app.post('/api/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) return res.status(400).json({ message: 'email and password required' });

    const q = await db.query(
      'select id,email,password_hash,role,created_at from users where email=$1',
      [email]
    );
    if (!q.rows.length) return res.status(401).json({ message: 'Invalid credentials' });

    const user = q.rows[0];
    const ok = await bcrypt.compare(password, user.password_hash);
    if (!ok) return res.status(401).json({ message: 'Invalid credentials' });

    const token = signToken(user);
    res.json({ token, user: { id: user.id, email: user.email, role: user.role, created_at: user.created_at } });
  } catch (e) {
    console.error(e);
    res.status(500).json({ message: 'Error logging in' });
  }
});

// Me
app.get('/api/me', authenticateToken, (req, res) => {
  res.json({ user: req.user });
});

// Create bet (stored to DB)
app.post('/api/bets', authenticateToken, async (req, res) => {
  try {
    const { route, transportType, cost, deliveryDays, isCounterBid, originalBetId } = req.body;

    if (!route || !transportType || cost == null || deliveryDays == null) {
      return res.status(400).json({ message: 'route, transportType, cost, deliveryDays required' });
    }

    const betId = crypto.randomUUID();

    const payload = {
      id: betId,
      userId: req.user.id,
      userEmail: req.user.email,
      userRole: req.user.role,
      route,
      transportType,
      cost,
      deliveryDays,
      isCounterBid: !!isCounterBid,
      originalBetId: originalBetId || null,
      createdAt: new Date().toISOString()
    };

    const ins = await db.query(
      'insert into bets(bet_id, data) values ($1, $2::jsonb) returning bet_id, data, created_at',
      [betId, JSON.stringify(payload)]
    );

    const row = ins.rows[0];
    res.json({ ...row.data, bet_id: row.bet_id, created_at: row.created_at });
  } catch (e) {
    console.error(e);
    res.status(500).json({ message: 'Error creating bet' });
  }
});

// Get bets (role-based, using jsonb fields)
app.get('/api/bets', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;

    let sql;
    let params = [userId];

    if (req.user.role === 'logistician') {
      sql = `
        select bet_id, data, created_at
        from bets b
        where
          (b.data->>'userId')::bigint = $1
          or (
            coalesce((b.data->>'isCounterBid')::boolean, false) = true
            and exists (
              select 1
              from bets b0
              where b0.bet_id = b.data->>'originalBetId'
                and (b0.data->>'userId')::bigint = $1
            )
          )
        order by created_at desc
        limit 200
      `;
    } else {
      sql = `
        select bet_id, data, created_at
        from bets b
        where
          (b.data->>'userRole') = 'logistician'
          or (
            coalesce((b.data->>'isCounterBid')::boolean, false) = true
            and (b.data->>'userId')::bigint = $1
          )
        order by created_at desc
        limit 200
      `;
    }

    const q = await db.query(sql, params);
    res.json(q.rows.map(r => ({ ...r.data, bet_id: r.bet_id, created_at: r.created_at })));
  } catch (e) {
    console.error(e);
    res.status(500).json({ message: 'Error fetching bets' });
  }
});

// Available routes and container types
app.get('/api/routes', (req, res) => res.json(routes));
app.get('/api/container-types', (req, res) => res.json(containerTypes));

// Best offers (static demo)
app.get('/api/best-offers', (req, res) => {
  res.json([
    { id: 1, from: 'Москва', to: 'Шанхай', price: 270000, days: 35, containerType: "20' Heavy" },
    { id: 2, from: 'Москва', to: 'Нингбо', price: 274000, days: 32, containerType: "20' Heavy" },
    { id: 3, from: 'Москва', to: 'Циндао', price: 279000, days: 34, containerType: "20' Heavy" },
    { id: 4, from: 'Москва', to: 'Яньтянь', price: 288000, days: 36, containerType: "20' Heavy" }
  ]);
});

// Start with DB check
(async () => {
  try {
    await db.query('select 1');
    console.log('DB: OK');
  } catch (e) {
    console.error('DB: FAIL', e);
    process.exit(1);
  }

  app.listen(PORT, () => console.log(`Server is running on port ${PORT}`));
})();
