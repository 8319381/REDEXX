require('dotenv').config();

const express = require('express');
const cors = require('cors');
const db = require("./db");
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 3001;

if (!process.env.JWT_SECRET) {
  console.error("FATAL: JWT_SECRET is not set in .env");
  process.exit(1);
}

app.use(cors());
app.use(express.json());

// Static lists (ok to keep in code)
const routes = [
  { from: 'Москва', to: 'Шанхай' },
  { from: 'Москва', to: 'Пекин' },
  { from: 'Москва', to: 'Нингбо' },
  { from: 'Москва', to: 'Циндао' },
  { from: 'Москва', to: 'Яньтянь' },
  { from: 'Санкт-Петербург', to: 'Шанхай' },
  { from: 'Санкт-Петербург', to: 'Пекин' },
  { from: 'Санкт-Петербург', to: 'Нингбо' },
  { from: 'Екатеринбург', to: 'Шанхай' },
  { from: 'Екатеринбург', to: 'Гуанчжоу' }
];
const containerTypes = ['20\'', '20\' Heavy', '40\'', '40\' HC'];

// Auth middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.sendStatus(401);

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
};

// REGISTER -> DB
app.post('/api/register', async (req, res) => {
  try {
    const { email, password, role } = req.body;

    if (!email || !password || !role) {
      return res.status(400).json({ message: 'email, password, role required' });
    }

    const existing = await db.query("SELECT id FROM users WHERE email=$1", [email]);
    if (existing.rows.length > 0) {
      return res.status(400).json({ message: 'User already exists' });
    }

    const passwordHash = await bcrypt.hash(password, 10);

    const inserted = await db.query(
      "INSERT INTO users(email, password_hash, role) VALUES ($1,$2,$3) RETURNING id, email, role",
      [email, passwordHash, role]
    );

    const user = inserted.rows[0];

    const token = jwt.sign(
      { id: user.id, email: user.email, role: user.role },
      process.env.JWT_SECRET
    );

    res.json({ token, user });
  } catch (error) {
    console.error("register error:", error);
    res.status(500).json({ message: 'Error creating user' });
  }
});

// LOGIN -> DB
app.post('/api/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    const q = await db.query(
      "SELECT id, email, password_hash, role FROM users WHERE email=$1",
      [email]
    );
    const user = q.rows[0];

    if (!user || !(await bcrypt.compare(password, user.password_hash))) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { id: user.id, email: user.email, role: user.role },
      process.env.JWT_SECRET
    );

    res.json({ token, user: { id: user.id, email: user.email, role: user.role } });
  } catch (error) {
    console.error("login error:", error);
    res.status(500).json({ message: 'Error logging in' });
  }
});

// POST BET -> DB (bets.bet_id + bets.data jsonb)
app.post('/api/bets', authenticateToken, async (req, res) => {
  try {
    const { route, transportType, cost, deliveryDays, isCounterBid, originalBetId } = req.body;

    const bet_id = crypto.randomUUID();

    const payload = {
      id: bet_id,
      userId: String(req.user.id),
      userEmail: req.user.email,
      userRole: req.user.role,
      route,
      transportType,
      cost: (cost === undefined || cost === null) ? null : Number(cost),
      deliveryDays: (deliveryDays === undefined || deliveryDays === null) ? null : Number(deliveryDays),
      isCounterBid: !!isCounterBid,
      originalBetId: originalBetId || null
    };

    const ins = await db.query(
      "INSERT INTO bets(bet_id, data) VALUES ($1, $2::jsonb) RETURNING created_at",
      [bet_id, JSON.stringify(payload)]
    );

    res.json({ ...payload, createdAt: ins.rows[0].created_at });
  } catch (error) {
    console.error("bets post error:", error);
    res.status(500).json({ message: 'Error creating bet' });
  }
});

// GET BETS -> DB + фильтрация как раньше
app.get('/api/bets', authenticateToken, async (req, res) => {
  try {
    const q = await db.query(
      "SELECT bet_id, data, created_at FROM bets ORDER BY created_at DESC",
      []
    );

    const all = q.rows.map(r => {
      const d = r.data || {};
      return {
        id: r.bet_id,
        ...d,
        // если вдруг внутри data лежит id, всё равно норм
        createdAt: r.created_at
      };
    });

    const byId = new Map(all.map(b => [String(b.id), b]));

    let userBets;
    if (req.user.role === 'logistician') {
      userBets = all.filter(bet => {
        if (String(bet.userId) === String(req.user.id)) return true;
        if (bet.isCounterBid && bet.originalBetId) {
          const orig = byId.get(String(bet.originalBetId));
          if (orig && String(orig.userId) === String(req.user.id)) return true;
        }
        return false;
      });
    } else {
      userBets = all.filter(bet => {
        if (bet.userRole === 'logistician') return true;
        if (bet.isCounterBid && String(bet.userId) === String(req.user.id)) return true;
        return false;
      });
    }

    res.json(userBets);
  } catch (error) {
    console.error("bets get error:", error);
    res.status(500).json({ message: 'Error fetching bets' });
  }
});

// Available routes and container types
app.get('/api/routes', (req, res) => res.json(routes));
app.get('/api/container-types', (req, res) => res.json(containerTypes));

// Best offers (still mocked)
app.get('/api/best-offers', (req, res) => {
  const bestOffers = [
    { id: 1, from: 'Москва', to: 'Шанхай', price: 270000, days: 35, containerType: '20\' Heavy' },
    { id: 2, from: 'Москва', to: 'Нингбо',  price: 274000, days: 32, containerType: '20\' Heavy' },
    { id: 3, from: 'Москва', to: 'Циндао',  price: 279000, days: 34, containerType: '20\' Heavy' },
    { id: 4, from: 'Москва', to: 'Яньтянь', price: 288000, days: 36, containerType: '20\' Heavy' }
  ];
  res.json(bestOffers);
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
